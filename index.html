<!doctype html>
<html lang="en">
  <head>
    <!-- [DEBUG] Eruda: in-browser devtools for iPad/iPhone debugging.
	     Uncomment when debugging on touch devices that lack native devtools.
	<script src="//cdn.jsdelivr.net/npm/eruda"></script>
	<script>eruda.init();</script>
	-->
    <meta charset="UTF-8" />

    <meta
      name="description"
      content="Free online Markdown, Math (LaTeX), Mermaid, and PlantUML renderer and viewer in your browser. Privacy-focused, client-side rendering tool with dark mode support. No data leaves your browser unless you explicitly allow PlantUML rendering."
    />
    <meta
      name="keywords"
      content="GRSMD, markdown viewer, markdown renderer, markdown preview, mermaid viewer, mermaid diagrams, plantuml viewer, plantuml online, latex viewer, latex renderer, katex, diagram tool, markdown editor, privacy markdown tool, client-side markdown"
    />
    <meta name="author" content="GoodRelax" />
    <meta name="robots" content="index, follow" />

    <meta property="og:type" content="website" />
    <meta
      property="og:url"
      content="https://goodrelax.github.io/gr-simple-md-renderer/"
    />
    <meta
      property="og:title"
      content="GRSMD | Free Markdown Viewer ‚Äì Mermaid, PlantUML & Math"
    />
    <meta
      property="og:description"
      content="Privacy-focused online tool for rendering Markdown, Math (LaTeX), Mermaid, and PlantUML diagrams with syntax highlighting and dark mode."
    />

    <meta property="twitter:card" content="summary_large_image" />
    <meta
      property="twitter:title"
      content="GRSMD | Free Markdown Viewer ‚Äì Mermaid, PlantUML & Math"
    />
    <meta
      property="twitter:description"
      content="Privacy-focused online tool for rendering Markdown, Math (LaTeX), Mermaid, and PlantUML diagrams."
    />

    <title>GRSMD | Free Markdown Viewer ‚Äì Mermaid, PlantUML & Math</title>

    <script type="application/ld+json">
      {
        "@context": "https://schema.org",
        "@type": "SoftwareApplication",
        "name": "GR Simple MD Renderer & Viewer",
        "applicationCategory": "DeveloperApplication",
        "operatingSystem": "Web Browser",
        "offers": {
          "@type": "Offer",
          "price": "0",
          "priceCurrency": "USD"
        },
        "description": "GRSMD Free online viewer and renderer for Markdown, Math (LaTeX), Mermaid, and PlantUML. Features privacy-focused client-side rendering.",
        "author": {
          "@type": "Organization",
          "name": "GoodRelax",
          "url": "https://github.com/GoodRelax"
        }
      }
    </script>

    <style>
      body {
        margin: 0;
        font-family: sans-serif;
        display: flex;
        flex-direction: column;
        height: 100vh;
        overflow: hidden;
      }

      #topbar {
        display: flex;
        align-items: center;
        padding: 8px 12px;
        background: #f0f0f0;
        gap: 16px;
        border-bottom: 1px solid #ccc;
      }

      #header-group {
        display: flex;
        flex-direction: column;
        justify-content: center;
        flex-shrink: 0;
      }

      #title {
        font-weight: bold;
        font-size: 14px;
        font-family: "Arial Narrow", "Helvetica Neue", Arial, sans-serif;
        font-stretch: condensed;
        line-height: 1.2;
        white-space: nowrap;
      }

      #copyright {
        font-size: 10px;
        line-height: 1.2;
        margin-top: 2px;
      }

      #copyright a {
        color: blue;
        text-decoration: underline;
      }

      #controls {
        display: flex;
        align-self: stretch;
        gap: 8px;
        flex-shrink: 0;
      }

      #controls button {
        white-space: normal;
        text-align: center;
        line-height: 1.3;
        padding: 2px 8px;
        font-size: 12px;
        display: flex;
        align-items: center;
        justify-content: center;
      }

      #editor {
        flex: 1;
        font-family: monospace;
        font-size: 14px;
        padding: 4px 8px;
        border: 1px solid #ccc;
        height: 24px;
        min-height: 24px;
        resize: vertical;
        white-space: pre;
        overflow-y: auto;
      }

      #helpBtn {
        flex: 0 0 24px;
        align-self: stretch;
        cursor: pointer;
        font-weight: bold;
        padding: 0;
        display: flex;
        align-items: center;
        justify-content: center;
        -webkit-user-select: none;
        -moz-user-select: none;
        user-select: none;
      }

      #preview {
        flex: 1;
        overflow: auto;
        padding: 20px;
      }

      pre {
        background: #f4f4f4;
        padding: 12px;
        border-radius: 4px;
        overflow-x: auto;
      }

      blockquote {
        border-left: 4px solid #ccc;
        margin: 0;
        padding-left: 16px;
        color: #666;
      }

      /* Mermaid diagram container.
		   overflow:auto and drag-scroll styles are added for fine-pointer (PC) devices
		   only via the media query below, giving each diagram its own independent
		   scroll area when zoomed.
		   On touch devices the container stays clip-free so native pinch-zoom is unaffected. */
      .mermaid {
        display: flex;
        justify-content: flex-start;
        margin: 16px 0;
        position: relative;
      }

      /* Center the SVG inside .mermaid via auto margins.
		   When the SVG is narrower than the container, margin:auto absorbs the
		   free space and the diagram appears centered.
		   When the SVG overflows (large zoom), auto margins resolve to 0 and
		   flex-start takes over, putting the left edge at the scroll origin
		   so the full content is reachable. */
      .mermaid > svg {
        margin: auto;
      }

      /* Wrapper injected around every PlantUML <img> at render time.
		   Mirrors the per-diagram scroll strategy used for .mermaid. */
      .plantuml-wrapper {
        display: flex;
        justify-content: flex-start;
        margin: 16px 0;
        position: relative;
      }
      .plantuml-wrapper > img {
        margin: auto;
      }

      .diagram-copy-bar {
        display: flex;
        justify-content: flex-end;
        gap: 4px;
      }

      .diagram-copy-btn {
        padding: 2px 8px;
        font-size: 11px;
        cursor: pointer;
        background: rgba(255, 255, 255, 0.9);
        border: 1px solid #aaa;
        border-radius: 3px;
        user-select: none;
      }

      .dark .diagram-copy-btn {
        background: rgba(50, 50, 50, 0.9);
        border-color: #666;
        color: #eee;
      }

      /* PC (fine pointer = mouse/trackpad):
		   - overflow:auto  gives each diagram its own independent scroll area.
		   - cursor:grab    signals that the diagram can be panned by dragging.
		   - user-select:none prevents accidental text selection during drag;
		     SVG label text is rarely needed to copy in a diagram viewer context. */
      @media (pointer: fine) {
        .mermaid {
          overflow: auto;
          cursor: grab;
          user-select: none;
        }

        .plantuml-wrapper {
          overflow: auto;
          cursor: grab;
          user-select: none;
        }
      }

      /* Touch-capable devices (iPhone, iPad, iPad + Magic Keyboard, touchscreen PCs):
		   Switch from the "app shell" layout (body fixed at 100vh, #preview scrolls)
		   to natural document-level scrolling.
		   - "pointer: coarse" only matches when the PRIMARY pointer is touch (plain
		     iPhone/iPad without keyboard). It misses iPad + Magic Keyboard, where the
		     trackpad becomes the primary (fine) pointer while the touchscreen is still
		     present as a secondary coarse pointer.
		   - "any-pointer: coarse" matches whenever ANY pointer is touch, covering both
		     cases correctly.
		   After iOS pinch-zoom, visual-viewport panning (1-finger swipe) moves the
		   visual viewport over the document. With document-level scroll this IS
		   document scrolling (window.scrollY changes). With an overflow element
		   (#preview overflow:auto), viewport panning does not update
		   element.scrollTop, so the user cannot scroll past the zoomed area. */
      @media (any-pointer: coarse) {
        body {
          height: auto;
          overflow: auto;
        }

        #topbar {
          position: sticky;
          top: 0;
          z-index: 100;
        }

        #preview {
          flex: none;
          overflow: visible;
        }
      }

      @media print {
        body {
          height: auto;
          overflow: visible;
        }

        #topbar {
          display: none;
        }

        #editor {
          display: none;
        }

        #preview {
          overflow: visible;
          height: auto;
          flex: none;
        }
      }

      .plantuml-error {
        border: 2px dashed #ff6b6b;
        padding: 12px;
        margin: 8px 0;
        border-radius: 4px;
        background-color: #fff5f5;
        color: #c92a2a;
        font-family: monospace;
        font-size: 13px;
      }

      .modal {
        display: none;
        position: fixed;
        z-index: 1000;
        left: 0;
        top: 0;
        width: 100%;
        height: 100%;
        overflow: auto;
        background-color: rgba(0, 0, 0, 0.6);
      }

      .modal-content {
        background-color: #fefefe;
        margin: 5% auto;
        padding: 20px 30px;
        border: 1px solid #888;
        width: 80%;
        max-width: 700px;
        border-radius: 8px;
        box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
        line-height: 1.6;
      }

      .close-btn {
        color: #aaa;
        float: right;
        font-size: 28px;
        font-weight: bold;
        cursor: pointer;
        line-height: 1;
      }

      .close-btn:hover,
      .close-btn:focus {
        color: black;
        text-decoration: none;
        cursor: pointer;
      }

      .modal-section {
        margin-bottom: 24px;
      }

      .modal-section h3 {
        margin-bottom: 8px;
        border-bottom: 1px solid #ddd;
        padding-bottom: 4px;
      }

      .modal-section ul {
        margin-top: 8px;
        padding-left: 20px;
      }

      #promptText {
        width: 100%;
        height: 200px;
        margin-bottom: 10px;
        resize: none;
        font-family: monospace;
        font-size: 12px;
        padding: 8px;
        box-sizing: border-box;
        background: #f4f4f4;
        border: 1px solid #ccc;
        color: #333;
      }

      #copyPromptBtn {
        width: 100%;
        padding: 10px;
        cursor: pointer;
        font-weight: bold;
      }

      body.dark {
        background: #222;
        color: #ddd;
      }

      .dark #topbar {
        background: #333;
        border-bottom: 1px solid #444;
      }

      .dark #editor {
        background: #444;
        color: #fff;
        border-color: #666;
      }

      .dark pre {
        background: #333;
        border: 1px solid #555;
      }

      .dark #copyright a {
        color: #66b3ff;
      }

      .dark .modal-content {
        background-color: #333;
        color: #eee;
        border: 1px solid #555;
      }

      .dark .close-btn {
        color: #ddd;
      }

      .dark .close-btn:hover {
        color: #fff;
      }

      .dark .modal-section h3 {
        border-bottom-color: #555;
      }

      .dark #promptText {
        background: #444;
        border: 1px solid #666;
        color: #fff;
      }

      .dark .plantuml-error {
        background-color: #2d1f1f;
        color: #ff8787;
        border-color: #ff6b6b;
      }

      .dark .katex {
        color: inherit;
      }

      .katex {
        font-size: 1.5em;
      }
    </style>

    <!--
        SRI Hash Generation Site
            https://srihash.org/
        CDN sites
            https://www.jsdelivr.com/package/npm/marked
            https://www.jsdelivr.com/package/npm/mermaid
            https://cdnjs.com/libraries/highlight.js
            https://www.jsdelivr.com/package/npm/katex
            https://www.jsdelivr.com/package/npm/marked-katex-extension
    -->

    <script
      src="https://cdn.jsdelivr.net/npm/marked@17.0.1/lib/marked.umd.min.js"
      integrity="sha384-AkwdwVgEdZpqPMfydlmViIGgV90b6sHb/NoxnNdlecRKY3puoyKdw/pi64E32c+6"
      crossorigin="anonymous"
    ></script>

    <link
      rel="modulepreload"
      href="https://cdn.jsdelivr.net/npm/mermaid@11.12.2/dist/mermaid.esm.min.mjs"
      integrity="sha384-bBdf+Hx1qc+N2a4poQjInyeO803gqSNqanHQiQ3DgvXaz/aeQz4mQLhIXpK9MP83"
      crossorigin="anonymous"
    />

    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.11.1/styles/vs2015.min.css"
      integrity="sha512-mtXspRdOWHCYp+f4c7CkWGYPPRAhq9X+xCvJMUBVAb6pqA4U8pxhT3RWT3LP3bKbiolYL2CkL1bSKZZO4eeTew=="
      crossorigin="anonymous"
      referrerpolicy="no-referrer"
    />
    <link
      rel="modulepreload"
      href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.11.1/es/highlight.min.js"
      integrity="sha512-818kY2uYH1PRlHNZZL17hgbHng9LBOgA4k8TQVsXYTaKwgg5pMxBahxeHDUdAMTPUJ82CXLQmJZOl3OQUKZ18Q=="
      crossorigin="anonymous"
      referrerpolicy="no-referrer"
    />

    <link
      rel="modulepreload"
      href="https://cdn.jsdelivr.net/npm/plantuml-encoder@1.4.0/+esm"
      integrity="sha384-0soUzyKltgTFXRsH4USkmq6FPG3emb/n2JkcG7etR4fIXjKFFJkCLqTl6sM7boxe"
      crossorigin="anonymous"
    />

    <link
      rel="stylesheet"
      href="https://cdn.jsdelivr.net/npm/katex@0.16.28/dist/katex.min.css"
      integrity="sha384-Wsr4Nh3yrvMf2KCebJchRJoVo1gTU6kcP05uRSh5NV3sj9+a8IomuJoQzf3sMq4T"
      crossorigin="anonymous"
    />
    <link
      rel="modulepreload"
      href="https://cdn.jsdelivr.net/npm/marked-katex-extension@5.1.6/+esm"
      integrity="sha384-sXM6dT1KwUCU7buT3pldq9hy6hhfkoUXunVhnhf+ISmpQh3ofLks2w7oMwyG24Ex"
      crossorigin="anonymous"
    />
  </head>

  <body>
    <div id="topbar">
      <div id="header-group">
        <div id="title">GR Simple MD Renderer &amp; Viewer</div>
        <div id="copyright">
          <a href="https://github.com/GoodRelax" target="_blank"
            >&copy; 2026 GoodRelax. MIT License.</a
          >
        </div>
      </div>

      <textarea id="editor" placeholder="Paste Markdown..."></textarea>

      <div id="controls">
        <button id="renderLight">Render<br />Light</button>
        <button id="renderDark">Render<br />Dark</button>
        <button id="newTabBtn">New<br />Tab</button>
        <button id="clearBtn">Clear</button>
      </div>

      <button id="helpBtn" title="Help">?</button>
    </div>

    <div id="preview"></div>

    <div id="helpModal" class="modal">
      <div class="modal-content">
        <div
          style="
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            margin-bottom: 16px;
          "
        >
          <h2 style="margin: 0">
            GoodRelax Simple Markdown Renderer &amp; Viewer
          </h2>
          <span class="close-btn">&times;</span>
        </div>

        <div class="modal-section">
          <h3>About GRSMD</h3>
          <p>
            GRSMD is a lightweight, privacy-first Markdown viewer that runs
            entirely in your browser.<br />
            It supports Markdown, Mermaid diagrams, and PlantUML &mdash; no
            backend, no data sent anywhere without your explicit consent.
          </p>
        </div>

        <div class="modal-section">
          <h3>Basic Usage</h3>
          <p>Any of the following triggers an automatic preview:</p>
          <ol>
            <li>Paste text anywhere on the page (Ctrl+V / Cmd+V)</li>
            <li>
              Drop a <code>.md</code> / <code>.txt</code> file anywhere on the
              page
            </li>
            <li>
              Paste text directly into the <code>[Paste Markdown...]</code> box
              at the top
            </li>
            <li>
              Drop a <code>.md</code> / <code>.txt</code> file onto the
              <code>[Paste Markdown...]</code> box at the top
            </li>
          </ol>
        </div>

        <div class="modal-section">
          <h3>Details</h3>
          <ul>
            <li><code>[Render Light]</code> : Preview in light mode</li>
            <li><code>[Render Dark]</code> : Preview in dark mode</li>
            <li><code>[New Tab]</code> : Open GRSMD in a new tab</li>
            <li><code>[Clear]</code> : Clear the editor and reset</li>
            <li><code>[?]</code> : Show this help</li>
            <li>
              <code>[?]</code> (long press) : Display a prompt template for
              generating clean Markdown with AI. Copy it and instruct the AI to
              output in MCBSMD format.
            </li>
            <li>
              Zoom (PC): Ctrl + mouse wheel over a diagram. Double-click to
              reset. Mac pinch also works.
            </li>
            <li>Pan (PC): Click and drag inside a diagram.</li>
          </ul>
        </div>

        <div class="modal-section">
          <h3>Privacy &amp; Security</h3>
          <ul>
            <li>
              PlantUML is the only exception to client-side-only operation. This
              tool shows a confirmation dialog before sending any PlantUML data
              to the official server.
            </li>
            <li>
              HTML embedded in Markdown is not sanitized. Paste only content you
              trust.
            </li>
          </ul>
        </div>

        <div class="modal-section">
          <h3>Sample Data</h3>
          <a
            href="https://goodrelax.github.io/gr-simple-md-renderer/sample-data.txt"
            target="_blank"
            rel="noopener noreferrer"
            >Copy this sample Markdown text for a quick trial</a
          ><br />
          <a
            href="https://goodrelax.github.io/gr-simple-md-renderer/sample-data-2.txt"
            target="_blank"
            rel="noopener noreferrer"
            >Copy this sample Markdown text for a large-scale data trial</a
          >
        </div>

        <div class="modal-section">
          <h3>Ê¶ÇË¶Å (Japanese)</h3>
          <p>
            GRSMD„ÅØ„ÄÅ„Åô„Åπ„Å¶„ÅÆÂá¶ÁêÜ„Çí„Éñ„É©„Ç¶„Ç∂ÂÜÖ„ÅßÂÆåÁµê„Åï„Åõ„ÇãËªΩÈáè„Éª„Éó„É©„Ç§„Éê„Ç∑„ÉºÂÑ™ÂÖà„ÅÆMarkdown„Éì„É•„Éº„ÉØ„Éº„Åß„Åô„ÄÇ<br />
            Markdown„ÄÅMermaid„ÉÄ„Ç§„Ç¢„Ç∞„É©„É†„ÄÅPlantUML„Å´ÂØæÂøú„Åó„ÄÅÊòéÁ§∫ÁöÑ„Å™ÂêåÊÑè„Å™„Åó„Å´„Éá„Éº„Çø„ÅåÂ§ñÈÉ®„Å∏ÈÄÅ‰ø°„Åï„Çå„Çã„Åì„Å®„ÅØ„ÅÇ„Çä„Åæ„Åõ„Çì„ÄÇ
          </p>
        </div>

        <div class="modal-section">
          <h3>Âü∫Êú¨ÁöÑ„Å™‰Ωø„ÅÑÊñπ (Japanese)</h3>
          <p>‰ª•‰∏ã„ÅÆ„ÅÑ„Åö„Çå„Åã„Å´„Çà„ÇäËá™ÂãïÁöÑ„Å´„Éó„É¨„Éì„É•„ÉºË°®Á§∫„Åï„Çå„Åæ„Åô„ÄÇ</p>
          <ol>
            <li>„Éö„Éº„Ç∏‰∏ä„ÅÆ„Å©„Åì„Åã„Å´„ÉÜ„Ç≠„Çπ„Éà„Çí„Éö„Éº„Çπ„ÉàÔºàCtrl+V / Cmd+VÔºâ</li>
            <li>
              <code>.md</code> /
              <code>.txt</code> „Éï„Ç°„Ç§„É´„Çí„Éö„Éº„Ç∏‰∏ä„ÅÆ„Å©„Åì„Åã„Å´„Éâ„É©„ÉÉ„Ç∞ÔºÜ„Éâ„É≠„ÉÉ„Éó
            </li>
            <li>
              ÁîªÈù¢‰∏äÈÉ®„ÅÆ
              <code>[Paste Markdown...]</code> „Å´„ÉÜ„Ç≠„Çπ„Éà„ÇíÁõ¥Êé•„Éö„Éº„Çπ„Éà
            </li>
            <li>
              ÁîªÈù¢‰∏äÈÉ®„ÅÆ <code>[Paste Markdown...]</code> „Å´ <code>.md</code> /
              <code>.txt</code> „Éï„Ç°„Ç§„É´„Çí„Éâ„É©„ÉÉ„Ç∞ÔºÜ„Éâ„É≠„ÉÉ„Éó
            </li>
          </ol>
        </div>

        <div class="modal-section">
          <h3>Ë©≥Á¥∞ (Japanese)</h3>
          <ul>
            <li><code>[Render Light]</code> : „É©„Ç§„Éà„É¢„Éº„Éâ„Åß„Éó„É¨„Éì„É•„Éº</li>
            <li><code>[Render Dark]</code> : „ÉÄ„Éº„ÇØ„É¢„Éº„Éâ„Åß„Éó„É¨„Éì„É•„Éº</li>
            <li><code>[New Tab]</code> : Êñ∞„Åó„ÅÑ„Çø„Éñ„ÅßGRSMD„ÇíÈñã„Åè</li>
            <li><code>[Clear]</code> : ÂàùÊúüÂåñ</li>
            <li><code>[?]</code> : Êú¨„Éò„É´„Éó„ÇíË°®Á§∫</li>
            <li>
              <code>[?]</code> Èï∑Êäº„Åó :
              AI„Å´Á∂∫È∫ó„Å™Markdown„ÇíÁîüÊàê„Åï„Åõ„Çã„Åü„ÇÅ„ÅÆ„Éó„É≠„É≥„Éó„Éà„ÉÜ„É≥„Éó„É¨„Éº„Éà„ÇíË°®Á§∫„ÄÇ„Ç≥„Éî„Éº„Åó„Å¶AI„Å´MCBSMDÂΩ¢Âºè„ÅßÁµêÊûú„ÇíÂá∫Âäõ„Åô„Çã„Çà„ÅÜÊåáÁ§∫„Åô„Çã„Å®„Çà„ÅÑ„ÄÇ
            </li>
            <li>
              Âõ≥„ÅÆÊã°Â§ß (PC): Ctrl +
              „Éû„Ç¶„Çπ„Éõ„Ç§„Éº„É´„ÄÇ„ÉÄ„Éñ„É´„ÇØ„É™„ÉÉ„ÇØ„Åß„É™„Çª„ÉÉ„Éà„ÄÇMac„Éî„É≥„ÉÅ„ÇÇÂèØ„ÄÇ
            </li>
            <li>Âõ≥„ÅÆË°®Á§∫‰ΩçÁΩÆ„ÇíÁßªÂãï (PC): Âõ≥„ÅÆ‰∏ä„Åß„ÇØ„É™„ÉÉ„ÇØÔºÜ„Éâ„É©„ÉÉ„Ç∞„ÄÇ</li>
          </ul>
        </div>

        <div class="modal-section">
          <h3>„Éó„É©„Ç§„Éê„Ç∑„Éº„Å®„Çª„Ç≠„É•„É™„ÉÜ„Ç£ (Japanese)</h3>
          <ul>
            <li>
              PlantUML:
              „ÇØ„É©„Ç§„Ç¢„É≥„Éà„Çµ„Ç§„ÉâÂãï‰Ωú„ÅÆÂîØ‰∏Ä„ÅÆ‰æãÂ§ñ„ÄÇÂÖ¨Âºè„Çµ„Éº„Éê„Éº„Å´PlantUML„Éá„Éº„Çø„ÇíÈÄÅ‰ø°„Åô„ÇãÂâç„Å´„ÄÅ„Åì„ÅÆ„ÉÑ„Éº„É´„ÅåÁ¢∫Ë™ç„ÉÄ„Ç§„Ç¢„É≠„Ç∞„ÇíË°®Á§∫„Åó„Åæ„Åô„ÄÇ
            </li>
            <li>
              MarkdownÂÜÖ„ÅÆHTML„ÅØ„Çµ„Éã„Çø„Ç§„Ç∫„Åï„Çå„Åæ„Åõ„Çì„ÄÇ‰ø°È†º„Åß„Åç„Çã„Ç≥„É≥„ÉÜ„É≥„ÉÑ„ÅÆ„ÅøË≤º„Çä‰ªò„Åë„Çã„Åì„Å®„ÄÇ
            </li>
          </ul>
        </div>
      </div>
    </div>

    <div id="promptModal" class="modal">
      <div class="modal-content">
        <span class="close-btn prompt-close">&times;</span>
        <div class="modal-section">
          <h3>Prompt for AI Markdown Generation</h3>
          <p>
            The prompt below improves the quality of the AI's Markdown output by
            reducing errors.<br />
            Copy this prompt and instruct your AI to output in MCBSMD format.
          </p>

          <textarea id="promptText" readonly></textarea>
          <button id="copyPromptBtn">Copy to Clipboard</button>
        </div>
      </div>
    </div>

    <script type="module">
      import mermaid from "https://cdn.jsdelivr.net/npm/mermaid@11.12.2/dist/mermaid.esm.min.mjs";
      import hljs from "https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.11.1/es/highlight.min.js";
      import plantumlEncoder from "https://cdn.jsdelivr.net/npm/plantuml-encoder@1.4.0/+esm";
      import markedKatex from "https://cdn.jsdelivr.net/npm/marked-katex-extension@5.1.6/+esm";

      // ========================================
      // Configuration
      // ========================================
      const CONFIG = {
        rendering: {
          stabilityTimeout: 1000,
          stabilityDebounce: 50,
        },
        plantuml: {
          imageLoadTimeout: 5000,
          serverUrl: "https://www.plantuml.com/plantuml/svg/",
          darkTheme: "cyborg",
        },
        ui: {
          longPressDuration: 300,
          copyFeedbackDuration: 250,
          maxTextSelection: 99999,
        },
        zoom: {
          min: 0.5,
          max: 5.0,
          step: 0.1,
        },
        pan: {
          activationThresholdPx: 5,
        },
        fileDrop: {
          maxBytes: 5 * 1024 * 1024,
          allowedExtensions: [".md", ".txt"],
        },
        messages: {
          plantuml: {
            canceled: "Rendering Canceled",
            encodingFailed: "PlantUML encoding failed",
            timeout: (seconds) => `PlantUML timeout (${seconds}s)`,
            serverError: "PlantUML server error",
          },
          copy: {
            failed: "Copy failed.",
            blocked: "Browser denied copy.",
          },
          fileDrop: {
            invalidType: "Acceptable file types are .md and .txt only.",
            tooLarge:
              "Dropped file is too large. Acceptable file size is maximum 5 MB.",
            readError: "Failed to read file.",
          },
        },
      };

      // ========================================
      // Type Definitions
      // ========================================

      /**
       * @typedef {Object} UIElements
       * @property {HTMLTextAreaElement} editor
       * @property {HTMLElement} preview
       * @property {HTMLButtonElement} renderLightBtn
       * @property {HTMLButtonElement} renderDarkBtn
       * @property {HTMLButtonElement} newTabBtn
       * @property {HTMLButtonElement} clearBtn
       * @property {HTMLButtonElement} helpBtn
       * @property {HTMLElement} helpModal
       * @property {HTMLElement} promptModal
       * @property {HTMLTextAreaElement} promptText
       * @property {HTMLButtonElement} copyPromptBtn
       */

      // ========================================
      // Utility Functions
      // ========================================

      /**
       * Wait until the element's size stops changing before restoring scroll position.
       * Mermaid and PlantUML resize their containers after rendering, which would
       * otherwise cause unexpected scroll jumps.
       * @param {HTMLElement} element
       * @param {number} timeout
       * @returns {Promise<boolean>}
       */
      async function waitForDOMStability(
        element,
        timeout = CONFIG.rendering.stabilityTimeout,
      ) {
        return new Promise((resolve) => {
          let resizeTimer;
          let timeoutTimer;

          const resizeObserver = new ResizeObserver(() => {
            clearTimeout(resizeTimer);
            resizeTimer = setTimeout(() => {
              cleanup();
              resolve(true);
            }, CONFIG.rendering.stabilityDebounce);
          });

          const cleanup = () => {
            resizeObserver.disconnect();
            clearTimeout(resizeTimer);
            clearTimeout(timeoutTimer);
          };

          resizeObserver.observe(element);

          timeoutTimer = setTimeout(() => {
            cleanup();
            console.warn(
              "DOM stability timeout after",
              timeout,
              "ms (continuing anyway)",
            );
            resolve(false);
          }, timeout);
        });
      }

      // ========================================
      // Utility Classes
      // ========================================

      /**
       * Replace a code block element (and its <pre> parent if present) with newElement.
       * @param {HTMLElement} block
       * @param {HTMLElement} newElement
       */
      function replaceCodeBlock(block, newElement) {
        const pre = block.parentElement;
        if (pre && pre.tagName === "PRE") {
          pre.replaceWith(newElement);
        } else {
          block.replaceWith(newElement);
        }
      }

      // ========================================
      // Class: ApplicationState
      // ========================================

      /**
       * Holds mutable application-level state.
       */
      class ApplicationState {
        constructor() {
          this.currentTheme = "light";
          this.markdownText = "";
        }

        /** @param {string} theme */
        setTheme(theme) {
          this.currentTheme = theme;
        }

        /** @param {string} text */
        setMarkdownText(text) {
          this.markdownText = text;
        }
      }

      // ========================================
      // Class: ScrollManager
      // ========================================

      /**
       * Saves and restores the scroll position of a container element.
       *
       * On touch devices (pointer:coarse) the app uses document-level scroll
       * instead of #preview overflow scroll (see CSS @media pointer:coarse).
       * In that mode, window.scrollY / window.scrollTo() are used so that the
       * same "scroll position restore after re-render" behaviour is available
       * on iPad/iPhone as on PC.
       */
      class ScrollManager {
        /** @param {HTMLElement} container */
        constructor(container) {
          this.container = container;
          this.useDocumentScroll = window.matchMedia(
            "(any-pointer: coarse)",
          ).matches;
        }

        /** @returns {number} */
        save() {
          return this.useDocumentScroll
            ? window.scrollY
            : this.container.scrollTop;
        }

        /** @param {number} pos */
        restore(pos) {
          if (this.useDocumentScroll) {
            window.scrollTo(0, pos);
          } else {
            this.container.scrollTop = pos;
          }
        }
      }

      // ========================================
      // Class: MarkdownRenderer
      // ========================================

      /**
       * Parses Markdown and applies syntax highlighting to code blocks.
       */
      class MarkdownRenderer {
        /**
         * @param {HTMLElement} preview
         * @param {object} marked
         * @param {object} hljs
         */
        constructor(preview, marked, hljs) {
          this.preview = preview;
          this.marked = marked;
          this.hljs = hljs;
        }

        /** @param {string} markdownText */
        async render(markdownText) {
          try {
            const html = this.marked.parse(markdownText);
            this.preview.innerHTML = html;

            try {
              // Skip diagram blocks; they have their own rendering pipelines.
              this.preview
                .querySelectorAll(
                  "pre code:not(.language-mermaid):not(.language-plantuml):not(.language-puml)",
                )
                .forEach((block) => {
                  this.hljs.highlightElement(block);
                });
            } catch (hljsError) {
              console.error("Syntax highlighting error:", hljsError);
            }
          } catch (error) {
            console.error("Markdown parse error:", error);
            this.preview.innerHTML = `<pre style="color:red;">Markdown Parse Error: ${error.message}</pre>`;
          }
        }
      }

      // ========================================
      // Class: DiagramRenderer (abstract base)
      // ========================================

      /**
       * Base interface for diagram renderers.
       * Subclasses must implement render(theme, skipRendering).
       */
      class DiagramRenderer {
        /**
         * @param {string} theme
         * @param {boolean} [skipRendering]
         */
        async render(theme, skipRendering) {
          throw new Error("DiagramRenderer.render() must be implemented");
        }
      }

      // ========================================
      // Class: MermaidRenderer
      // ========================================

      /**
       * Renders Mermaid diagram code blocks as SVG.
       */
      class MermaidRenderer extends DiagramRenderer {
        /**
         * @param {HTMLElement} preview
         * @param {object} mermaid
         */
        constructor(preview, mermaid) {
          super();
          this.preview = preview;
          this.mermaid = mermaid;
        }

        /** @param {string} theme @param {boolean} [_skipRendering=false] */
        async render(theme, _skipRendering = false) {
          try {
            const blocks = this.preview.querySelectorAll(
              "code.language-mermaid",
            );
            if (blocks.length === 0) return;

            blocks.forEach((block) => this.convertCodeBlockToContainer(block));
            this.initializeMermaid(theme);
            await this.renderMermaid();
          } catch (error) {
            console.error("Mermaid rendering error:", error);
          }
        }

        /** @param {string} theme */
        initializeMermaid(theme) {
          this.mermaid.initialize({
            startOnLoad: false,
            theme: theme === "dark" ? "dark" : "default",
          });
        }

        async renderMermaid() {
          try {
            await this.mermaid.run({
              nodes: this.preview.querySelectorAll(".mermaid"),
            });
          } catch (error) {
            console.error("Mermaid execution error:", error);
          }
        }

        /**
         * Replace a <code class="language-mermaid"> block with a .mermaid container div.
         * @param {HTMLElement} block
         * @returns {HTMLElement}
         */
        convertCodeBlockToContainer(block) {
          const container = document.createElement("div");
          container.className = "mermaid";
          container.textContent = block.textContent;
          container.title =
            "Ctrl+Scroll: zoom | Double-click: reset | Drag: pan";

          replaceCodeBlock(block, container);
          return container;
        }
      }

      // ========================================
      // Class: PlantUMLRenderer
      // ========================================

      /**
       * Renders PlantUML diagram code blocks as <img> elements via the external server.
       * Each image is wrapped in a .plantuml-wrapper div to provide an independent
       * per-diagram scroll area when zoomed on PC.
       */
      class PlantUMLRenderer extends DiagramRenderer {
        /**
         * @param {HTMLElement} preview
         * @param {object} plantumlEncoder
         */
        constructor(preview, plantumlEncoder) {
          super();
          this.preview = preview;
          this.encoder = plantumlEncoder;
        }

        /** @param {string} theme */
        async render(theme) {
          try {
            const blocks = this.preview.querySelectorAll(
              "code.language-plantuml, code.language-puml",
            );
            if (blocks.length === 0) return;

            const permitted = window.confirm(
              `Security & Confidentiality Warning

` +
                `Your data will be sent to an external PlantUML rendering server.

` +
                `[OK]: data -> üåê official server -> render PlantUML

` +
                `[Cancel]: Render Markdown without PlantUML`,
            );

            if (!permitted) {
              blocks.forEach((block) => {
                const errorDiv = this.createErrorElement(
                  CONFIG.messages.plantuml.canceled,
                );
                replaceCodeBlock(block, errorDiv);
              });
              return;
            }

            const promises = [];
            blocks.forEach((block) => {
              const promise = this.renderSingleBlock(block, theme);
              if (promise) promises.push(promise);
            });
            await Promise.allSettled(promises);
          } catch (error) {
            console.error("PlantUML rendering error:", error);
          }
        }

        /**
         * Render one PlantUML block.
         * The <img> is placed inside a .plantuml-wrapper div so that on PC the diagram
         * gets its own horizontal scroll area instead of overflowing #preview.
         * @param {HTMLElement} block
         * @param {string} theme
         * @returns {Promise<boolean>|null}
         */
        renderSingleBlock(block, theme) {
          try {
            const code = this.applyTheme(block.textContent, theme);
            const img = this.createImage(code);
            const wrapper = this.createWrapper(img);
            replaceCodeBlock(block, wrapper);
            return this.waitForImageLoad(img, CONFIG.plantuml.imageLoadTimeout);
          } catch (error) {
            console.error("PlantUML encoding error:", error);
            const errorDiv = this.createErrorElement(
              CONFIG.messages.plantuml.encodingFailed,
            );
            replaceCodeBlock(block, errorDiv);
            return null;
          }
        }

        /**
         * Inject the dark theme directive if not already present.
         * @param {string} code
         * @param {string} theme
         * @returns {string}
         */
        applyTheme(code, theme) {
          if (theme === "dark" && !code.includes("!theme")) {
            return code.replace(
              /(@start\w+.*)/i,
              `$1\n!theme ${CONFIG.plantuml.darkTheme}`,
            );
          }
          return code;
        }

        /**
         * Build the <img> element pointing to the PlantUML server.
         * @param {string} code
         * @returns {HTMLImageElement}
         */
        createImage(code) {
          const encoded = this.encoder.encode(code);
          const img = document.createElement("img");
          img.src = `${CONFIG.plantuml.serverUrl}${encoded}`;
          img.alt = "PlantUML Diagram";
          img.className = "plantuml-diagram";
          img.title = "Ctrl+Scroll: zoom | Double-click: reset | Drag: pan";
          img.style.maxWidth = "100%";
          return img;
        }

        /**
         * Wrap an <img> in a .plantuml-wrapper div.
         * The wrapper is the independent scroll container for the diagram.
         * @param {HTMLImageElement} img
         * @returns {HTMLDivElement}
         */
        createWrapper(img) {
          const wrapper = document.createElement("div");
          wrapper.className = "plantuml-wrapper";
          wrapper.appendChild(img);
          return wrapper;
        }

        /**
         * @param {HTMLImageElement} img
         * @param {number} timeout ms
         * @returns {Promise<boolean>}
         */
        async waitForImageLoad(img, timeout) {
          return new Promise((resolve) => {
            const timer = setTimeout(() => {
              const errorDiv = this.createErrorElement(
                CONFIG.messages.plantuml.timeout(timeout / 1000),
              );
              img.replaceWith(errorDiv);
              resolve(false);
            }, timeout);

            img.onload = () => {
              clearTimeout(timer);
              resolve(true);
            };

            img.onerror = () => {
              clearTimeout(timer);
              const errorDiv = this.createErrorElement(
                CONFIG.messages.plantuml.serverError,
              );
              img.replaceWith(errorDiv);
              resolve(false);
            };
          });
        }

        /**
         * @param {string} message
         * @returns {HTMLDivElement}
         */
        createErrorElement(message) {
          const div = document.createElement("div");
          div.className = "plantuml-error";
          div.textContent = message;
          return div;
        }
      }

      // ========================================
      // Class: RendererOrchestrator
      // ========================================

      /**
       * Coordinates the full rendering pipeline:
       * Markdown -> Mermaid -> PlantUML -> DOM stability -> scroll restore.
       */
      class RendererOrchestrator {
        /**
         * @param {ApplicationState} state
         * @param {MarkdownRenderer} markdownRenderer
         * @param {MermaidRenderer} mermaidRenderer
         * @param {PlantUMLRenderer} plantumlRenderer
         * @param {ScrollManager} scrollManager
         * @param {HTMLElement} preview
         */
        constructor(
          state,
          markdownRenderer,
          mermaidRenderer,
          plantumlRenderer,
          scrollManager,
          preview,
        ) {
          this.state = state;
          this.markdownRenderer = markdownRenderer;
          this.mermaidRenderer = mermaidRenderer;
          this.plantumlRenderer = plantumlRenderer;
          this.scrollManager = scrollManager;
          this.preview = preview;
        }

        async renderAll() {
          try {
            const scrollTop = this.scrollManager.save();

            await this.markdownRenderer.render(this.state.markdownText);
            await this.mermaidRenderer.render(this.state.currentTheme);
            await this.plantumlRenderer.render(this.state.currentTheme);

            await waitForDOMStability(this.preview);
            this.scrollManager.restore(scrollTop);
          } catch (error) {
            console.error("Rendering orchestration error:", error);
          }
        }
      }

      // ========================================
      // Class: ModalController
      // ========================================

      /**
       * Static helpers for showing and closing modal dialogs.
       */
      class ModalController {
        /**
         * Wire up close buttons and backdrop click for a modal.
         * @param {HTMLElement} modal
         * @param {HTMLElement[]} closeTriggers
         */
        static setupModal(modal, closeTriggers) {
          closeTriggers.forEach((trigger) => {
            trigger.onclick = () => ModalController.hide(modal);
          });
          modal.addEventListener("click", (event) => {
            if (!event.target.closest(".modal-content"))
              ModalController.hide(modal);
          });
        }

        /** @param {HTMLElement} modal */
        static show(modal) {
          modal.style.display = "block";
        }

        /** @param {HTMLElement} modal */
        static hide(modal) {
          modal.style.display = "none";
        }
      }

      // ========================================
      // Class: DiagramZoomController
      // ========================================

      /**
       * Per-diagram zoom for PC (Ctrl+scroll or trackpad pinch).
       * Double-click resets a diagram to 100%.
       * Only instantiated when the device has a fine pointer (mouse/trackpad).
       */
      class DiagramZoomController {
        /** @param {HTMLElement} preview */
        constructor(preview) {
          this.preview = preview;
          this.scales = new WeakMap(); // Element -> current scale factor
          this.baseWidths = new WeakMap(); // Element -> rendered width at scale 1.0
          this.origMaxWidths = new WeakMap(); // Element -> original inline max-width value
          this.setupListeners();
        }

        setupListeners() {
          // passive:false is required so we can call preventDefault() to suppress
          // the browser's own Ctrl+scroll page zoom when the cursor is over a diagram.
          this.preview.addEventListener(
            "wheel",
            (e) => {
              if (!e.ctrlKey) return;
              const diagram = this.findDiagramAt(e.target);
              if (!diagram) return;
              e.preventDefault();
              this.zoom(diagram, e.deltaY < 0 ? 1 : -1);
            },
            { passive: false },
          );

          this.preview.addEventListener("dblclick", (e) => {
            const diagram = this.findDiagramAt(e.target);
            if (!diagram) return;
            this.resetZoom(diagram);
          });
        }

        /**
         * Return the zoomable element for the given event target.
         *
         * For Mermaid: return the <svg> inside the .mermaid container.
         *   Zooming the <svg> directly (not .mermaid) lets the element's layout size
         *   grow beyond the flex container, which then overflows into .mermaid's
         *   own scroll area (overflow:auto on PC).
         *
         * For PlantUML: return the .plantuml-diagram <img>.
         *   The img sits inside .plantuml-wrapper (overflow:auto on PC).
         *
         * @param {EventTarget} target
         * @returns {SVGSVGElement|HTMLImageElement|HTMLElement|null}
         */
        findDiagramAt(target) {
          const mermaidContainer = target.closest(".mermaid");
          if (mermaidContainer) {
            // Fallback to container if Mermaid has not rendered the SVG yet.
            return mermaidContainer.querySelector("svg") ?? mermaidContainer;
          }
          return target.closest(".plantuml-diagram");
        }

        /**
         * Increase or decrease scale by one step and apply.
         * Captures the element's rendered width the first time it is zoomed.
         * @param {Element} el
         * @param {number} direction +1 = zoom in, -1 = zoom out
         */
        zoom(el, direction) {
          if (!this.baseWidths.has(el)) {
            this.baseWidths.set(el, el.getBoundingClientRect().width);
            this.origMaxWidths.set(el, el.style.maxWidth);
          }

          const current = this.scales.get(el) ?? 1.0;
          const raw = current + direction * CONFIG.zoom.step;
          const next =
            Math.round(
              Math.max(CONFIG.zoom.min, Math.min(CONFIG.zoom.max, raw)) * 100,
            ) / 100;

          this.scales.set(el, next);
          this.applyScale(el, next);
        }

        /**
         * Restore the element to 100% and clear all stored state for it.
         * No-op if the element was never zoomed (Mermaid's own max-width is still
         * intact and must not be touched).
         * applyScale must run before the WeakMap entries are deleted so that it
         * can still read origMaxWidths.
         * @param {Element} el
         */
        resetZoom(el) {
          if (!this.baseWidths.has(el)) return;
          this.applyScale(el, 1.0);
          this.scales.delete(el);
          this.baseWidths.delete(el);
          this.origMaxWidths.delete(el);
        }

        /**
         * Apply the given scale factor to el by setting an explicit pixel width.
         *
         * Why explicit width instead of CSS zoom:
         *   - For <svg>: viewBox preserves aspect ratio when only width is set.
         *   - For <img>: height adjusts automatically (browser default).
         *   - Avoids the CSS zoom / max-width interaction ambiguity.
         *
         * flex-shrink is set to 0 when scale > 1 to prevent the flex shrink
         * algorithm from collapsing the explicitly-set width back to the container
         * width, which would suppress overflow and hide the scrollbar.
         *
         * @param {Element} el
         * @param {number} scale
         */
        applyScale(el, scale) {
          if (scale === 1.0) {
            el.style.width = "";
            el.style.height = "";
            el.style.flexShrink = "";
            // Restore original max-width (e.g. Mermaid's inline 'NNNpx', or '100%' for img).
            el.style.maxWidth =
              this.origMaxWidths.get(el) ??
              (el.tagName === "IMG" ? "100%" : "");
          } else {
            const baseWidth = this.baseWidths.get(el);
            if (baseWidth === undefined) return;
            // Clear max-width so it cannot clamp our explicit width.
            el.style.maxWidth = "none";
            el.style.height = "auto";
            el.style.width = `${Math.round(baseWidth * scale)}px`;
            // Disable flex shrink so the explicit width is not reduced back to
            // the container width by the flex layout algorithm.
            el.style.flexShrink = "0";
          }
        }
      }

      // ========================================
      // Class: DiagramPanController
      // ========================================

      /**
       * Per-diagram drag-to-pan for PC.
       * Left-click and drag scrolls the diagram's independent scroll container.
       * Only instantiated when the device has a fine pointer (mouse/trackpad).
       */
      class DiagramPanController {
        /** @param {HTMLElement} preview */
        constructor(preview) {
          this.preview = preview;
          this.panState = null;
          this.setupListeners();
        }

        setupListeners() {
          this.preview.addEventListener("mousedown", (e) => {
            if (e.button !== 0) return;
            const container = this.findScrollContainerAt(e.target);
            if (!container) return;
            e.preventDefault();
            this.panState = {
              container,
              startX: e.clientX,
              startY: e.clientY,
              lastX: e.clientX,
              lastY: e.clientY,
              active: false,
            };
          });

          document.addEventListener("mousemove", (e) => {
            const s = this.panState;
            if (!s) return;
            if (!s.active) {
              const dx = e.clientX - s.startX;
              const dy = e.clientY - s.startY;
              const t = CONFIG.pan.activationThresholdPx;
              if (dx * dx + dy * dy < t * t) return;
              s.active = true;
              this.setCursor(s.container, true);
            }
            s.container.scrollLeft -= e.clientX - s.lastX;
            // Scroll the diagram container vertically if it has vertical overflow
            // (e.g. a wide diagram where the container itself clips). Otherwise
            // fall back to scrolling #preview so vertical drag works when the
            // container grows with the zoomed content.
            const dy = e.clientY - s.lastY;
            if (s.container.scrollHeight > s.container.clientHeight) {
              s.container.scrollTop -= dy;
            } else {
              this.preview.scrollTop -= dy;
            }
            s.lastX = e.clientX;
            s.lastY = e.clientY;
          });

          document.addEventListener("mouseup", () => {
            if (!this.panState) return;
            if (this.panState.active) {
              this.setCursor(this.panState.container, false);
            }
            this.panState = null;
          });
        }

        /**
         * Set or clear the grabbing cursor on both the diagram container and document body.
         * @param {HTMLElement} container
         * @param {boolean} active
         */
        setCursor(container, active) {
          const cursor = active ? "grabbing" : "";
          container.style.cursor = cursor;
          document.body.style.cursor = cursor;
        }

        /**
         * Return the diagram scroll container (.mermaid or .plantuml-wrapper)
         * that contains the given event target, or null if none.
         * @param {EventTarget} target
         * @returns {HTMLElement|null}
         */
        findScrollContainerAt(target) {
          return (
            target.closest(".mermaid") ?? target.closest(".plantuml-wrapper")
          );
        }
      }

      // ========================================
      // Class: DiagramCopyController
      // ========================================

      /**
       * Shows persistent "Copy SVG" and "Copy PNG" buttons above each diagram.
       * A MutationObserver watches #preview and inserts a .diagram-copy-bar div
       * before each .mermaid / .plantuml-wrapper element whenever diagrams are
       * added or replaced after rendering.
       *
       * SVG export pipeline (Mermaid):
       *   1. inlineSvgStyles  - inline computed CSS as SVG presentation attributes
       *                         so Office apps that ignore <style> blocks still render
       *                         fill, font-family, font-size, etc. correctly.
       *   2. convertForeignObjects - replace <foreignObject> nodes with SVG <text>
       *                         elements. PowerPoint ignores foreignObject entirely,
       *                         causing class/flowchart/state/ER diagram labels to
       *                         disappear. Sequence diagrams are unaffected because
       *                         Mermaid renders their labels as native <text> elements.
       *
       * PNG export pipeline (Mermaid):
       *   Same prepareSvg, then SVG blob -> Image -> Canvas (2x) -> PNG blob.
       *   Using the foreignObject-free SVG avoids canvas tainting by the browser.
       *
       * PlantUML SVG: re-fetches /svg/ URL from the official server.
       * PlantUML PNG: re-fetches /png/ URL from the official server.
       *
       * Only instantiated on fine-pointer (mouse/trackpad) devices.
       */
      class DiagramCopyController {
        /** @param {HTMLElement} preview */
        constructor(preview) {
          this.preview = preview;
          this.observer = new MutationObserver(() => this.attachBars());
          this.observer.observe(this.preview, { childList: true, subtree: true });
        }

        attachBars() {
          this.preview
            .querySelectorAll(".mermaid, .plantuml-wrapper")
            .forEach((container) => {
              const prev = container.previousElementSibling;
              if (prev && prev.classList.contains("diagram-copy-bar")) return;
              this.attachBar(container);
            });
        }

        /** @param {HTMLElement} container */
        attachBar(container) {
          const bar = document.createElement("div");
          bar.className = "diagram-copy-bar";

          const svgBtn = document.createElement("button");
          svgBtn.className = "diagram-copy-btn";
          svgBtn.textContent = "Copy SVG";
          svgBtn.addEventListener("click", (e) => {
            e.stopPropagation();
            this.copyAsSvg(container, svgBtn);
          });

          const pngBtn = document.createElement("button");
          pngBtn.className = "diagram-copy-btn";
          pngBtn.textContent = "Copy PNG";
          pngBtn.addEventListener("click", (e) => {
            e.stopPropagation();
            this.copyAsPng(container, pngBtn);
          });

          bar.appendChild(svgBtn);
          bar.appendChild(pngBtn);
          container.parentElement.insertBefore(bar, container);
        }

        /**
         * Inline key SVG presentation attributes from computed styles.
         * Office apps ignore <style> blocks; inlining as attributes ensures
         * fill, font-family, font-size, etc. are preserved in PowerPoint/Excel.
         * @param {SVGSVGElement} svg
         * @returns {SVGSVGElement} deep clone with inlined attributes
         */
        inlineSvgStyles(svg) {
          const clone = svg.cloneNode(true);
          const origEls = [...svg.querySelectorAll("*")];
          const cloneEls = [...clone.querySelectorAll("*")];
          const props = [
            "fill", "fill-opacity", "stroke", "stroke-width",
            "font-family", "font-size", "font-weight", "font-style",
            "text-anchor", "dominant-baseline", "opacity", "visibility",
          ];
          origEls.forEach((orig, i) => {
            const s = getComputedStyle(orig);
            props.forEach((p) => {
              const v = s.getPropertyValue(p);
              if (v) cloneEls[i].setAttribute(p, v);
            });
          });
          return clone;
        }

        /**
         * Replace each <foreignObject> in the cloned SVG with an SVG <text> element.
         * PowerPoint ignores foreignObject entirely; this makes labels visible.
         * Text position is derived from the foreignObject x/y/width/height attrs.
         * Font style is read from the original live DOM via getComputedStyle.
         * @param {SVGSVGElement} svgClone - clone to modify
         * @param {SVGSVGElement} svgOrig  - original live element for style reads
         */
        convertForeignObjects(svgClone, svgOrig) {
          const origFOs = [...svgOrig.querySelectorAll("foreignObject")];
          const cloneFOs = [...svgClone.querySelectorAll("foreignObject")];

          origFOs.forEach((origFO, i) => {
            const cloneFO = cloneFOs[i];
            if (!cloneFO) return;

            const x = parseFloat(origFO.getAttribute("x") || 0);
            const y = parseFloat(origFO.getAttribute("y") || 0);
            const w = parseFloat(origFO.getAttribute("width") || 0);
            const h = parseFloat(origFO.getAttribute("height") || 0);

            const text = (origFO.textContent || "").trim().replace(/\s+/g, " ");
            if (!text) { cloneFO.remove(); return; }

            const innerEl = origFO.querySelector("span, p, div") || origFO;
            const s = getComputedStyle(innerEl);
            const fontSize = s.getPropertyValue("font-size") || "14px";
            const fontFamily = s.getPropertyValue("font-family") || "sans-serif";
            const fill = s.getPropertyValue("color") || "#000000";

            const textEl = document.createElementNS("http://www.w3.org/2000/svg", "text");
            textEl.setAttribute("text-anchor", "middle");
            textEl.setAttribute("dominant-baseline", "middle");
            textEl.setAttribute("font-size", fontSize);
            textEl.setAttribute("font-family", fontFamily);
            textEl.setAttribute("fill", fill);

            const lines = text.split(/[\n\r]+/).map((l) => l.trim()).filter(Boolean);
            if (lines.length === 1) {
              textEl.setAttribute("x", String(x + w / 2));
              textEl.setAttribute("y", String(y + h / 2));
              textEl.textContent = lines[0];
            } else {
              const lineH = parseFloat(fontSize) * 1.2;
              const totalH = (lines.length - 1) * lineH;
              textEl.setAttribute("x", String(x + w / 2));
              textEl.setAttribute("y", String(y + h / 2 - totalH / 2));
              lines.forEach((line, j) => {
                const tspan = document.createElementNS("http://www.w3.org/2000/svg", "tspan");
                tspan.setAttribute("x", String(x + w / 2));
                tspan.setAttribute("dy", j === 0 ? "0" : String(lineH));
                tspan.textContent = line;
                textEl.appendChild(tspan);
              });
            }

            cloneFO.parentElement.replaceChild(textEl, cloneFO);
          });
        }

        /**
         * Inline styles and convert foreignObjects on a clone of the given SVG.
         * Sets explicit pixel dimensions so Canvas rendering has a reliable size.
         * @param {SVGSVGElement} svg
         * @returns {SVGSVGElement}
         */
        prepareSvg(svg) {
          const clone = this.inlineSvgStyles(svg);
          this.convertForeignObjects(clone, svg);
          if (!clone.getAttribute("xmlns"))
            clone.setAttribute("xmlns", "http://www.w3.org/2000/svg");
          const bbox = svg.getBoundingClientRect();
          clone.setAttribute("width", String(bbox.width));
          clone.setAttribute("height", String(bbox.height));
          return clone;
        }

        /** @param {HTMLButtonElement} btn @param {string} msg @param {string} reset @param {number} [ms] */
        showFeedback(btn, msg, reset, ms = CONFIG.ui.copyFeedbackDuration) {
          btn.textContent = msg;
          setTimeout(() => { btn.textContent = reset; }, ms);
        }

        async copyAsSvg(container, btn) {
          try {
            let blob;
            if (container.classList.contains("mermaid")) {
              const svg = container.querySelector("svg");
              if (!svg) return;
              const svgText = new XMLSerializer().serializeToString(this.prepareSvg(svg));
              blob = new Blob([svgText], { type: "image/svg+xml" });
            } else {
              const img = container.querySelector("img.plantuml-diagram");
              if (!img) return;
              const svgText = await (await fetch(img.src)).text();
              blob = new Blob([svgText], { type: "image/svg+xml" });
            }
            await navigator.clipboard.write([new ClipboardItem({ "image/svg+xml": blob })]);
            this.showFeedback(btn, "Copied!", "Copy SVG");
          } catch (err) {
            console.error("SVG copy failed:", err);
            this.showFeedback(btn, "Failed", "Copy SVG", CONFIG.ui.copyFeedbackDuration * 4);
          }
        }

        async copyAsPng(container, btn) {
          try {
            let pngBlob;
            if (container.classList.contains("mermaid")) {
              const svg = container.querySelector("svg");
              if (!svg) return;
              const prepared = this.prepareSvg(svg);
              const svgText = new XMLSerializer().serializeToString(prepared);
              const url = URL.createObjectURL(new Blob([svgText], { type: "image/svg+xml" }));
              const scale = 2;
              const w = parseFloat(prepared.getAttribute("width")) * scale;
              const h = parseFloat(prepared.getAttribute("height")) * scale;
              const img = new Image();
              await new Promise((res, rej) => { img.onload = res; img.onerror = rej; img.src = url; });
              URL.revokeObjectURL(url);
              const canvas = document.createElement("canvas");
              canvas.width = w;
              canvas.height = h;
              const ctx = canvas.getContext("2d");
              ctx.scale(scale, scale);
              ctx.drawImage(img, 0, 0);
              pngBlob = await new Promise((res) => canvas.toBlob(res, "image/png"));
            } else {
              const img = container.querySelector("img.plantuml-diagram");
              if (!img) return;
              const pngUrl = img.src.replace("/plantuml/svg/", "/plantuml/png/");
              pngBlob = await (await fetch(pngUrl)).blob();
            }
            await navigator.clipboard.write([new ClipboardItem({ "image/png": pngBlob })]);
            this.showFeedback(btn, "Copied!", "Copy PNG");
          } catch (err) {
            console.error("PNG copy failed:", err);
            this.showFeedback(btn, "Failed", "Copy PNG", CONFIG.ui.copyFeedbackDuration * 4);
          }
        }
      }

      // ========================================
      // Class: UIController
      // ========================================

      /**
       * Translates UI events into use-case calls.
       * Primary responsibility: listen for user gestures (button clicks,
       * drag-and-drop, keyboard shortcuts, long-press) and delegate to the
       * orchestrator or state. Also owns lightweight input helpers
       * (preprocessInput, theme detection) that are too small to extract.
       *
       * Wires up all user-facing interactions:
       * render buttons, utility buttons, help/prompt modals, long-press, and
       * initial theme detection from the OS color-scheme preference.
       */
      class UIController {
        /**
         * @param {RendererOrchestrator} orchestrator
         * @param {ApplicationState} state
         * @param {UIElements} elements
         */
        constructor(orchestrator, state, elements) {
          this.orchestrator = orchestrator;
          this.state = state;
          this.elements = elements;
          this.longPressTimer = null;
          this.isLongPress = false;

          this.setupEventListeners();
          this.setupModals();
          this.setupPromptText();
        }

        setupEventListeners() {
          this.setupRenderButtons();
          this.setupUtilityButtons();
          this.setupHelpButton();
          this.setupPromptButton();
          this.setupFileDrop();
          this.setupAutoRenderOnPaste();
          // Apply OS color-scheme preference on first load.
          this.applySystemTheme();
        }

        /**
         * Strip an optional ```markdown fenced wrapper that AI tools sometimes add.
         * @param {string} rawText
         * @returns {string}
         */
        preprocessInput(rawText) {
          return rawText
            .replace(/^(?:\s*\n)*`{3,}markdown\s*\n/i, "")
            .replace(/\n`{3,}\s*$/i, "");
        }

        setupRenderButtons() {
          this.elements.renderLightBtn.addEventListener("click", async () => {
            await this.handleRender("light");
          });
          this.elements.renderDarkBtn.addEventListener("click", async () => {
            await this.handleRender("dark");
          });
        }

        setupUtilityButtons() {
          this.elements.newTabBtn.addEventListener("click", () => {
            window.open(window.location.href, "_blank");
          });
          this.elements.clearBtn.addEventListener("click", () => {
            this.elements.editor.value = "";
            this.elements.preview.innerHTML = "";
            // Restore the OS color-scheme preference instead of forcing light mode.
            this.applySystemTheme();
          });
        }

        /**
         * Validate a dropped file and load its text into the editor textarea.
         * Resolves on success, rejects (after alert) on validation / read failure.
         * No external communication occurs; FileReader is entirely client-side.
         * @param {File} file
         * @returns {Promise<void>}
         */
        loadFileIntoEditor(file) {
          const name = file.name.toLowerCase();
          const allowed = CONFIG.fileDrop.allowedExtensions.some((ext) =>
            name.endsWith(ext),
          );
          if (!allowed) {
            alert(CONFIG.messages.fileDrop.invalidType);
            return Promise.reject();
          }
          if (file.size > CONFIG.fileDrop.maxBytes) {
            alert(CONFIG.messages.fileDrop.tooLarge);
            return Promise.reject();
          }
          return new Promise((resolve, reject) => {
            const reader = new FileReader();
            reader.onload = (e) => {
              this.elements.editor.value = e.target.result;
              resolve();
            };
            reader.onerror = () => {
              alert(CONFIG.messages.fileDrop.readError);
              reject();
            };
            reader.readAsText(file);
          });
        }

        /**
         * Enable drag-and-drop of .md/.txt files onto the editor and the preview area.
         * In pre-render state, a successful drop also triggers auto-render.
         * The preview area only accepts drops in pre-render state.
         */
        setupFileDrop() {
          const { editor, preview } = this.elements;

          const acceptDrop = (e) => {
            e.preventDefault();
            e.dataTransfer.dropEffect = "copy";
          };

          // Editor: always accept drops; auto-render only in pre-render state.
          editor.addEventListener("dragover", acceptDrop);
          editor.addEventListener("drop", async (e) => {
            e.preventDefault();
            const file = e.dataTransfer.files[0];
            if (!file) return;
            const wasPreRender = this.isPreRenderState();
            try {
              await this.loadFileIntoEditor(file);
              if (wasPreRender) await this.handleRender(this.systemTheme());
            } catch {
              /* validation error already shown via alert */
            }
          });

          // Preview area: accept drops only in pre-render state; always auto-render.
          preview.addEventListener("dragover", (e) => {
            if (!this.isPreRenderState()) return;
            acceptDrop(e);
          });
          preview.addEventListener("drop", async (e) => {
            if (!this.isPreRenderState()) return;
            e.preventDefault();
            const file = e.dataTransfer.files[0];
            if (!file) return;
            try {
              await this.loadFileIntoEditor(file);
              await this.handleRender(this.systemTheme());
            } catch {
              /* validation error already shown via alert */
            }
          });
        }

        /**
         * In pre-render state, a Ctrl+V anywhere on the page (except other inputs)
         * populates the editor and immediately renders using the system color scheme.
         */
        setupAutoRenderOnPaste() {
          document.addEventListener("paste", async (e) => {
            // Do not intercept paste into other inputs (e.g. the prompt textarea).
            const target = e.target;
            const isOtherInput =
              (target.tagName === "TEXTAREA" || target.tagName === "INPUT") &&
              target !== this.elements.editor;
            if (isOtherInput) return;
            if (!this.isPreRenderState()) return;
            const text = e.clipboardData.getData("text/plain");
            if (!text) return;
            e.preventDefault();
            this.elements.editor.value = text;
            await this.handleRender(this.systemTheme());
          });
        }

        setupHelpButton() {
          this.elements.helpBtn.addEventListener("mousedown", (e) =>
            this.startPress(e),
          );
          this.elements.helpBtn.addEventListener("mouseup", () =>
            this.cancelPress(),
          );
          this.elements.helpBtn.addEventListener("mouseleave", () =>
            this.cancelPress(),
          );

          this.elements.helpBtn.addEventListener("touchstart", (e) =>
            this.startPress(e),
          );
          this.elements.helpBtn.addEventListener("touchend", (e) => {
            this.cancelPress();
            if (!this.isLongPress) {
              e.preventDefault();
              this.handleHelpClick(e);
            }
          });

          this.elements.helpBtn.addEventListener("click", (e) =>
            this.handleHelpClick(e),
          );
        }

        setupPromptButton() {
          this.elements.copyPromptBtn.addEventListener("click", async () => {
            const text = this.elements.promptText.value;
            if (navigator.clipboard) {
              try {
                await navigator.clipboard.writeText(text);
                this.showCopySuccess();
                return;
              } catch {
                // Fall through to execCommand fallback
              }
            }
            // Fallback for file:// or restricted contexts (deprecated but functional)
            this.elements.promptText.select();
            this.elements.promptText.setSelectionRange(
              0,
              CONFIG.ui.maxTextSelection,
            );
            try {
              const ok = document.execCommand("copy");
              if (ok) {
                this.showCopySuccess();
              } else {
                alert(CONFIG.messages.copy.failed);
              }
            } catch (err) {
              alert(CONFIG.messages.copy.blocked);
            }
          });
        }

        setupModals() {
          const helpCloseBtn =
            this.elements.helpModal.querySelector(".close-btn");
          const promptCloseBtn =
            this.elements.promptModal.querySelector(".prompt-close");
          ModalController.setupModal(this.elements.helpModal, [helpCloseBtn]);
          ModalController.setupModal(this.elements.promptModal, [
            promptCloseBtn,
          ]);
        }

        setupPromptText() {
          const COPY_PAYLOAD = `
## Output Format

- Output the entire content **as a single Markdown code block** so it can be copied in one go.
- **Enclose the entire Markdown with six backticks \` \`\`\`\`\`\` \` at the beginning and end.** Specify its language as markdown.
- **Use these six backticks only once as the outermost enclosure.**
- **Never output speculation or fabrications.** If something is unclear or requires investigation, explicitly state so.
- This method is called **MCBSMD** (Multiple Code Blocks in a Single Markdown)

### Code and Diagram Block Rules

- As a rule, use Mermaid for diagrams. Use PlantUML only when the diagram cannot be expressed in Mermaid.
- Any diagrams or software code inside the Markdown must each be enclosed in their own code blocks using triple backticks \` \`\`\` \`.
- Each code block must specify a language or file type (e.g., \` \`\`\`python \` or \` \`\`\`mermaid \`).
- Each code or diagram block must be preceded by a descriptive title in the format **title:**
  (e.g., \`**System Architecture:**\`, \`**Login Flow:**\`)
- Always follow the structure below for every code or diagram block:

  > **title:**
  >
  > \`\`\`language
  > (code or diagram content here without truncation or abbreviation)
  > \`\`\`
  >
  > Write the explanation for the code block here, immediately after the block, following a blank line.

- Do not write explanations inside the code blocks.
- In all diagrams, use alphanumeric characters and underscores (\`_\`) by default; non-ASCII plain text (no spaces) is permitted when necessary. Special symbols (e.g., \`\\\`, \`/\`, \`|\`, \`<\`, \`>\`, \`{\`, \`}\`) are strictly prohibited.
- Output all diagram content without omission. Never use \`...\` or any shorthand.

### Diagram Label and Notation Rules

- All arrows and relationship lines in diagrams MUST have labels. Follow these notation rules:
  1. Mermaid \`flowchart\` and \`graph\`: place the label inside the arrow using pipes (e.g., \`A -->|Label| B\`)
  2. Other Mermaid diagrams / All PlantUML: place the label after the arrow using a colon (e.g., \`A --> B : Label\`)
- For line breaks in labels or node text:
  1. Mermaid: use \`<br/>\` inside a quoted string (e.g., \`A -->|"Line1<br/>Line2"| B\`, \`A["Line1<br/>Line2"]\`)
  2. PlantUML: use \`\\n\` (e.g., \`A -> B : Line1\\nLine2\`)

### Math Rules

- Use standard LaTeX notation for all mathematical formulas.
  1. Inline math: always use single dollar signs. Place a space before the opening \`$\`
     and a space after the closing \`$\`
     (e.g., \`The function is $y = x + 1$ here.\`)
  2. Block equations: always place \`$$\` on its own line, above and below the formula.
     Example:
     > $$
     > E = mc^2
     > $$
`;
          this.elements.promptText.value = COPY_PAYLOAD;
        }

        /** @param {string} theme */
        async handleRender(theme) {
          const content = this.preprocessInput(this.elements.editor.value);

          this.state.setTheme(theme);
          this.state.setMarkdownText(content);
          this.applyTheme(theme);

          await this.orchestrator.renderAll();
        }

        /** @param {string} theme */
        applyTheme(theme) {
          if (theme === "dark") {
            document.body.classList.add("dark");
          } else {
            document.body.classList.remove("dark");
          }
        }

        /**
         * Returns 'dark' or 'light' based on the OS/browser color-scheme preference.
         * @returns {'dark'|'light'}
         */
        systemTheme() {
          return window.matchMedia("(prefers-color-scheme: dark)").matches
            ? "dark"
            : "light";
        }

        /**
         * True only when both the editor and preview are empty (nothing typed or rendered yet).
         * Used to gate auto-render on paste and drag-and-drop.
         * @returns {boolean}
         */
        isPreRenderState() {
          return (
            this.elements.preview.children.length === 0 &&
            this.elements.editor.value.trim() === ""
          );
        }

        /**
         * Read the OS/browser color-scheme preference and apply it as the initial theme.
         * Called once at construction time and also by the Clear button to restore
         * the OS preference after clearing the preview.
         */
        applySystemTheme() {
          const theme = this.systemTheme();
          this.state.setTheme(theme);
          this.applyTheme(theme);
        }

        /** @param {Event} e */
        startPress(e) {
          if (e.type === "mousedown" && e.button !== 0) return;
          this.isLongPress = false;
          this.longPressTimer = setTimeout(() => {
            this.isLongPress = true;
            ModalController.show(this.elements.promptModal);
          }, CONFIG.ui.longPressDuration);
        }

        cancelPress() {
          clearTimeout(this.longPressTimer);
        }

        /** @param {Event} e */
        handleHelpClick(e) {
          if (this.isLongPress) {
            e.preventDefault();
            e.stopPropagation();
            this.isLongPress = false;
            return;
          }
          ModalController.show(this.elements.helpModal);
        }

        showCopySuccess() {
          const original = this.elements.copyPromptBtn.textContent;
          this.elements.copyPromptBtn.textContent = "Copied!";
          setTimeout(() => {
            this.elements.copyPromptBtn.textContent = original;
            ModalController.hide(this.elements.promptModal);
          }, CONFIG.ui.copyFeedbackDuration);
        }
      }

      // ========================================
      // Initialization
      // ========================================

      const elements = {
        editor: document.getElementById("editor"),
        preview: document.getElementById("preview"),
        renderLightBtn: document.getElementById("renderLight"),
        renderDarkBtn: document.getElementById("renderDark"),
        newTabBtn: document.getElementById("newTabBtn"),
        clearBtn: document.getElementById("clearBtn"),
        helpBtn: document.getElementById("helpBtn"),
        helpModal: document.getElementById("helpModal"),
        promptModal: document.getElementById("promptModal"),
        promptText: document.getElementById("promptText"),
        copyPromptBtn: document.getElementById("copyPromptBtn"),
      };

      marked.use(markedKatex({ throwOnError: false }));

      const state = new ApplicationState();
      const scrollManager = new ScrollManager(elements.preview);
      const markdownRenderer = new MarkdownRenderer(
        elements.preview,
        marked,
        hljs,
      );
      const mermaidRenderer = new MermaidRenderer(elements.preview, mermaid);
      const plantumlRenderer = new PlantUMLRenderer(
        elements.preview,
        plantumlEncoder,
      );
      const orchestrator = new RendererOrchestrator(
        state,
        markdownRenderer,
        mermaidRenderer,
        plantumlRenderer,
        scrollManager,
        elements.preview,
      );

      new UIController(orchestrator, state, elements);

      // DiagramZoomController: activated on any fine-pointer device (mouse/trackpad),
      // including iPad + Magic Keyboard. Ctrl+scroll zoom works via the trackpad.
      //
      // DiagramPanController: activated only on pure fine-pointer devices (no
      // touchscreen). On touch-capable devices the document-level scroll layout is
      // used; mouse-drag pan conflicts with touch scroll there and is not needed.
      const isTouchCapable = window.matchMedia("(any-pointer: coarse)").matches;
      if (window.matchMedia("(pointer: fine)").matches) {
        new DiagramZoomController(elements.preview);
        new DiagramCopyController(elements.preview);
        if (!isTouchCapable) {
          new DiagramPanController(elements.preview);
        }
      }
    </script>
  </body>
</html>
